
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>articles: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">realworld-backend/articles/models.go (37.5%)</option>
				
				<option value="file1">realworld-backend/articles/routers.go (0.0%)</option>
				
				<option value="file2">realworld-backend/articles/serializers.go (75.9%)</option>
				
				<option value="file3">realworld-backend/articles/validators.go (7.4%)</option>
				
				<option value="file4">realworld-backend/common/database.go (88.2%)</option>
				
				<option value="file5">realworld-backend/common/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package articles

import (
        _ "fmt"
        "github.com/jinzhu/gorm"
        "realworld-backend/common"
        "realworld-backend/users"
        "strconv"
)

type ArticleModel struct {
        gorm.Model
        Slug        string `gorm:"unique_index"`
        Title       string
        Description string `gorm:"size:2048"`
        Body        string `gorm:"size:2048"`
        Author      ArticleUserModel
        AuthorID    uint
        Tags        []TagModel     `gorm:"many2many:article_tags;"`
        Comments    []CommentModel `gorm:"ForeignKey:ArticleID"`
}

type ArticleUserModel struct {
        gorm.Model
        UserModel      users.UserModel
        UserModelID    uint
        ArticleModels  []ArticleModel  `gorm:"ForeignKey:AuthorID"`
        FavoriteModels []FavoriteModel `gorm:"ForeignKey:FavoriteByID"`
}

type FavoriteModel struct {
        gorm.Model
        Favorite     ArticleModel
        FavoriteID   uint
        FavoriteBy   ArticleUserModel
        FavoriteByID uint
}

type TagModel struct {
        gorm.Model
        Tag           string         `gorm:"unique_index"`
        ArticleModels []ArticleModel `gorm:"many2many:article_tags;"`
}

type CommentModel struct {
        gorm.Model
        Article   ArticleModel
        ArticleID uint
        Author    ArticleUserModel
        AuthorID  uint
        Body      string `gorm:"size:2048"`
}

func GetArticleUserModel(userModel users.UserModel) ArticleUserModel <span class="cov8" title="1">{
        var articleUserModel ArticleUserModel
        if userModel.ID == 0 </span><span class="cov0" title="0">{
                return articleUserModel
        }</span>
        <span class="cov8" title="1">db := common.GetDB()
        db.Where(&amp;ArticleUserModel{
                UserModelID: userModel.ID,
        }).FirstOrCreate(&amp;articleUserModel)
        articleUserModel.UserModel = userModel
        return articleUserModel</span>
}

func (article ArticleModel) favoritesCount() uint <span class="cov8" title="1">{
        db := common.GetDB()
        var count uint
        db.Model(&amp;FavoriteModel{}).Where(FavoriteModel{
                FavoriteID: article.ID,
        }).Count(&amp;count)
        return count
}</span>

func (article ArticleModel) isFavoriteBy(user ArticleUserModel) bool <span class="cov8" title="1">{
        db := common.GetDB()
        var favorite FavoriteModel
        db.Where(FavoriteModel{
                FavoriteID:   article.ID,
                FavoriteByID: user.ID,
        }).First(&amp;favorite)
        return favorite.ID != 0
}</span>

func (article ArticleModel) favoriteBy(user ArticleUserModel) error <span class="cov8" title="1">{
        db := common.GetDB()
        var favorite FavoriteModel
        err := db.FirstOrCreate(&amp;favorite, &amp;FavoriteModel{
                FavoriteID:   article.ID,
                FavoriteByID: user.ID,
        }).Error
        return err
}</span>

func (article ArticleModel) unFavoriteBy(user ArticleUserModel) error <span class="cov8" title="1">{
        db := common.GetDB()
        err := db.Where(FavoriteModel{
                FavoriteID:   article.ID,
                FavoriteByID: user.ID,
        }).Delete(FavoriteModel{}).Error
        return err
}</span>

func SaveOne(data interface{}) error <span class="cov0" title="0">{
        db := common.GetDB()
        err := db.Save(data).Error
        return err
}</span>

func FindOneArticle(condition interface{}) (ArticleModel, error) <span class="cov8" title="1">{
        db := common.GetDB()
        var model ArticleModel
        tx := db.Begin()
        tx.Where(condition).First(&amp;model)
        tx.Model(&amp;model).Related(&amp;model.Author, "Author")
        tx.Model(&amp;model.Author).Related(&amp;model.Author.UserModel)
        tx.Model(&amp;model).Related(&amp;model.Tags, "Tags")
        err := tx.Commit().Error
        return model, err
}</span>

func (self *ArticleModel) getComments() error <span class="cov0" title="0">{
        db := common.GetDB()
        tx := db.Begin()
        tx.Model(self).Related(&amp;self.Comments, "Comments")
        for i, _ := range self.Comments </span><span class="cov0" title="0">{
                tx.Model(&amp;self.Comments[i]).Related(&amp;self.Comments[i].Author, "Author")
                tx.Model(&amp;self.Comments[i].Author).Related(&amp;self.Comments[i].Author.UserModel)
        }</span>
        <span class="cov0" title="0">err := tx.Commit().Error
        return err</span>
}

func getAllTags() ([]TagModel, error) <span class="cov0" title="0">{
        db := common.GetDB()
        var models []TagModel
        err := db.Find(&amp;models).Error
        return models, err
}</span>

func FindManyArticle(tag, author, limit, offset, favorited string) ([]ArticleModel, int, error) <span class="cov0" title="0">{
        db := common.GetDB()
        var models []ArticleModel
        var count int

        offset_int, err := strconv.Atoi(offset)
        if err != nil </span><span class="cov0" title="0">{
                offset_int = 0
        }</span>

        <span class="cov0" title="0">limit_int, err := strconv.Atoi(limit)
        if err != nil </span><span class="cov0" title="0">{
                limit_int = 20
        }</span>

        <span class="cov0" title="0">tx := db.Begin()
        if tag != "" </span><span class="cov0" title="0">{
                var tagModel TagModel
                tx.Where(TagModel{Tag: tag}).First(&amp;tagModel)
                if tagModel.ID != 0 </span><span class="cov0" title="0">{
                        tx.Model(&amp;tagModel).Offset(offset_int).Limit(limit_int).Related(&amp;models, "ArticleModels")
                        count = tx.Model(&amp;tagModel).Association("ArticleModels").Count()
                }</span>
        } else<span class="cov0" title="0"> if author != "" </span><span class="cov0" title="0">{
                var userModel users.UserModel
                tx.Where(users.UserModel{Username: author}).First(&amp;userModel)
                articleUserModel := GetArticleUserModel(userModel)

                if articleUserModel.ID != 0 </span><span class="cov0" title="0">{
                        count = tx.Model(&amp;articleUserModel).Association("ArticleModels").Count()
                        tx.Model(&amp;articleUserModel).Offset(offset_int).Limit(limit_int).Related(&amp;models, "ArticleModels")
                }</span>
        } else<span class="cov0" title="0"> if favorited != "" </span><span class="cov0" title="0">{
                var userModel users.UserModel
                tx.Where(users.UserModel{Username: favorited}).First(&amp;userModel)
                articleUserModel := GetArticleUserModel(userModel)
                if articleUserModel.ID != 0 </span><span class="cov0" title="0">{
                        var favoriteModels []FavoriteModel
                        tx.Where(FavoriteModel{
                                FavoriteByID: articleUserModel.ID,
                        }).Offset(offset_int).Limit(limit_int).Find(&amp;favoriteModels)

                        count = tx.Model(&amp;articleUserModel).Association("FavoriteModels").Count()
                        for _, favorite := range favoriteModels </span><span class="cov0" title="0">{
                                var model ArticleModel
                                tx.Model(&amp;favorite).Related(&amp;model, "Favorite")
                                models = append(models, model)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                db.Model(&amp;models).Count(&amp;count)
                db.Offset(offset_int).Limit(limit_int).Find(&amp;models)
        }</span>

        <span class="cov0" title="0">for i, _ := range models </span><span class="cov0" title="0">{
                tx.Model(&amp;models[i]).Related(&amp;models[i].Author, "Author")
                tx.Model(&amp;models[i].Author).Related(&amp;models[i].Author.UserModel)
                tx.Model(&amp;models[i]).Related(&amp;models[i].Tags, "Tags")
        }</span>
        <span class="cov0" title="0">err = tx.Commit().Error
        return models, count, err</span>
}

func (self *ArticleUserModel) GetArticleFeed(limit, offset string) ([]ArticleModel, int, error) <span class="cov0" title="0">{
        db := common.GetDB()
        var models []ArticleModel
        var count int

        offset_int, err := strconv.Atoi(offset)
        if err != nil </span><span class="cov0" title="0">{
                offset_int = 0
        }</span>
        <span class="cov0" title="0">limit_int, err := strconv.Atoi(limit)
        if err != nil </span><span class="cov0" title="0">{
                limit_int = 20
        }</span>

        <span class="cov0" title="0">tx := db.Begin()
        followings := self.UserModel.GetFollowings()
        var articleUserModels []uint
        for _, following := range followings </span><span class="cov0" title="0">{
                articleUserModel := GetArticleUserModel(following)
                articleUserModels = append(articleUserModels, articleUserModel.ID)
        }</span>

        <span class="cov0" title="0">tx.Where("author_id in (?)", articleUserModels).Order("updated_at desc").Offset(offset_int).Limit(limit_int).Find(&amp;models)

        for i, _ := range models </span><span class="cov0" title="0">{
                tx.Model(&amp;models[i]).Related(&amp;models[i].Author, "Author")
                tx.Model(&amp;models[i].Author).Related(&amp;models[i].Author.UserModel)
                tx.Model(&amp;models[i]).Related(&amp;models[i].Tags, "Tags")
        }</span>
        <span class="cov0" title="0">err = tx.Commit().Error
        return models, count, err</span>
}

func (model *ArticleModel) setTags(tags []string) error <span class="cov8" title="1">{
        db := common.GetDB()
        var tagList []TagModel
        for _, tag := range tags </span><span class="cov8" title="1">{
                var tagModel TagModel
                err := db.FirstOrCreate(&amp;tagModel, TagModel{Tag: tag}).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tagList = append(tagList, tagModel)</span>
        }
        <span class="cov8" title="1">model.Tags = tagList
        return nil</span>
}

func (model *ArticleModel) Update(data interface{}) error <span class="cov0" title="0">{
        db := common.GetDB()
        err := db.Model(model).Update(data).Error
        return err
}</span>

func DeleteArticleModel(condition interface{}) error <span class="cov8" title="1">{
        db := common.GetDB()
        err := db.Where(condition).Delete(ArticleModel{}).Error
        return err
}</span>

func DeleteCommentModel(condition interface{}) error <span class="cov8" title="1">{
        db := common.GetDB()
        err := db.Where(condition).Delete(CommentModel{}).Error
        return err
}</span>

// AutoMigrate runs the auto migration for article models
func AutoMigrate() <span class="cov8" title="1">{
        db := common.GetDB()

        db.AutoMigrate(&amp;ArticleModel{})
        db.AutoMigrate(&amp;ArticleUserModel{})
        db.AutoMigrate(&amp;TagModel{})
        db.AutoMigrate(&amp;CommentModel{})
        db.AutoMigrate(&amp;FavoriteModel{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package articles

import (
        "errors"
        "realworld-backend/common"
        "realworld-backend/users"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

func ArticlesRegister(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.POST("/", ArticleCreate)
        router.PUT("/:slug", ArticleUpdate)
        router.DELETE("/:slug", ArticleDelete)
        router.POST("/:slug/favorite", ArticleFavorite)
        router.DELETE("/:slug/favorite", ArticleUnfavorite)
        router.POST("/:slug/comments", ArticleCommentCreate)
        router.DELETE("/:slug/comments/:id", ArticleCommentDelete)
}</span>

func ArticlesAnonymousRegister(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.GET("/", ArticleList)
        router.GET("/:slug", ArticleRetrieve)
        router.GET("/:slug/comments", ArticleCommentList)
}</span>

func TagsAnonymousRegister(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.GET("/", TagList)
}</span>

func ArticleCreate(c *gin.Context) <span class="cov0" title="0">{
        articleModelValidator := NewArticleModelValidator()
        if err := articleModelValidator.Bind(c); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnprocessableEntity, common.NewValidatorError(err))
                return
        }</span>
        //fmt.Println(articleModelValidator.articleModel.Author.UserModel)

        <span class="cov0" title="0">if err := SaveOne(&amp;articleModelValidator.articleModel); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnprocessableEntity, common.NewError("database", err))
                return
        }</span>
        <span class="cov0" title="0">serializer := ArticleSerializer{c, articleModelValidator.articleModel}
        c.JSON(http.StatusCreated, gin.H{"article": serializer.Response()})</span>
}

func ArticleList(c *gin.Context) <span class="cov0" title="0">{
        //condition := ArticleModel{}
        tag := c.Query("tag")
        author := c.Query("author")
        favorited := c.Query("favorited")
        limit := c.Query("limit")
        offset := c.Query("offset")
        articleModels, modelCount, err := FindManyArticle(tag, author, limit, offset, favorited)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid param")))
                return
        }</span>
        <span class="cov0" title="0">serializer := ArticlesSerializer{c, articleModels}
        c.JSON(http.StatusOK, gin.H{"articles": serializer.Response(), "articlesCount": modelCount})</span>
}

func ArticleFeed(c *gin.Context) <span class="cov0" title="0">{
        limit := c.Query("limit")
        offset := c.Query("offset")
        myUserModel := c.MustGet("my_user_model").(users.UserModel)
        if myUserModel.ID == 0 </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusUnauthorized, errors.New("{error : \"Require auth!\"}"))
                return
        }</span>
        <span class="cov0" title="0">articleUserModel := GetArticleUserModel(myUserModel)
        articleModels, modelCount, err := articleUserModel.GetArticleFeed(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid param")))
                return
        }</span>
        <span class="cov0" title="0">serializer := ArticlesSerializer{c, articleModels}
        c.JSON(http.StatusOK, gin.H{"articles": serializer.Response(), "articlesCount": modelCount})</span>
}

func ArticleRetrieve(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        if slug == "feed" </span><span class="cov0" title="0">{
                ArticleFeed(c)
                return
        }</span>
        <span class="cov0" title="0">articleModel, err := FindOneArticle(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">serializer := ArticleSerializer{c, articleModel}
        c.JSON(http.StatusOK, gin.H{"article": serializer.Response()})</span>
}

func ArticleUpdate(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        articleModel, err := FindOneArticle(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">articleModelValidator := NewArticleModelValidatorFillWith(articleModel)
        if err := articleModelValidator.Bind(c); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnprocessableEntity, common.NewValidatorError(err))
                return
        }</span>

        <span class="cov0" title="0">articleModelValidator.articleModel.ID = articleModel.ID
        if err := articleModel.Update(articleModelValidator.articleModel); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnprocessableEntity, common.NewError("database", err))
                return
        }</span>
        <span class="cov0" title="0">serializer := ArticleSerializer{c, articleModel}
        c.JSON(http.StatusOK, gin.H{"article": serializer.Response()})</span>
}

func ArticleDelete(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        err := DeleteArticleModel(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"article": "Delete success"})</span>
}

func ArticleFavorite(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        articleModel, err := FindOneArticle(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">myUserModel := c.MustGet("my_user_model").(users.UserModel)
        err = articleModel.favoriteBy(GetArticleUserModel(myUserModel))
        serializer := ArticleSerializer{c, articleModel}
        c.JSON(http.StatusOK, gin.H{"article": serializer.Response()})</span>
}

func ArticleUnfavorite(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        articleModel, err := FindOneArticle(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">myUserModel := c.MustGet("my_user_model").(users.UserModel)
        err = articleModel.unFavoriteBy(GetArticleUserModel(myUserModel))
        serializer := ArticleSerializer{c, articleModel}
        c.JSON(http.StatusOK, gin.H{"article": serializer.Response()})</span>
}

func ArticleCommentCreate(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        articleModel, err := FindOneArticle(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("comment", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">commentModelValidator := NewCommentModelValidator()
        if err := commentModelValidator.Bind(c); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnprocessableEntity, common.NewValidatorError(err))
                return
        }</span>
        <span class="cov0" title="0">commentModelValidator.commentModel.Article = articleModel

        if err := SaveOne(&amp;commentModelValidator.commentModel); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnprocessableEntity, common.NewError("database", err))
                return
        }</span>
        <span class="cov0" title="0">serializer := CommentSerializer{c, commentModelValidator.commentModel}
        c.JSON(http.StatusCreated, gin.H{"comment": serializer.Response()})</span>
}

func ArticleCommentDelete(c *gin.Context) <span class="cov0" title="0">{
        id64, err := strconv.ParseUint(c.Param("id"), 10, 32)
        id := uint(id64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("comment", errors.New("Invalid id")))
                return
        }</span>
        <span class="cov0" title="0">err = DeleteCommentModel([]uint{id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("comment", errors.New("Invalid id")))
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"comment": "Delete success"})</span>
}

func ArticleCommentList(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        articleModel, err := FindOneArticle(&amp;ArticleModel{Slug: slug})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("comments", errors.New("Invalid slug")))
                return
        }</span>
        <span class="cov0" title="0">err = articleModel.getComments()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("comments", errors.New("Database error")))
                return
        }</span>
        <span class="cov0" title="0">serializer := CommentsSerializer{c, articleModel.Comments}
        c.JSON(http.StatusOK, gin.H{"comments": serializer.Response()})</span>
}
func TagList(c *gin.Context) <span class="cov0" title="0">{
        tagModels, err := getAllTags()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, common.NewError("articles", errors.New("Invalid param")))
                return
        }</span>
        <span class="cov0" title="0">serializer := TagsSerializer{c, tagModels}
        c.JSON(http.StatusOK, gin.H{"tags": serializer.Response()})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package articles

import (
        "github.com/gosimple/slug"
        "realworld-backend/users"
        "github.com/gin-gonic/gin"
)

type TagSerializer struct {
        C *gin.Context
        TagModel
}

type TagsSerializer struct {
        C    *gin.Context
        Tags []TagModel
}

func (s *TagSerializer) Response() string <span class="cov8" title="1">{
        return s.TagModel.Tag
}</span>

func (s *TagsSerializer) Response() []string <span class="cov8" title="1">{
        response := []string{}
        for _, tag := range s.Tags </span><span class="cov8" title="1">{
                serializer := TagSerializer{s.C, tag}
                response = append(response, serializer.Response())
        }</span>
        <span class="cov8" title="1">return response</span>
}

type ArticleUserSerializer struct {
        C *gin.Context
        ArticleUserModel
}

func (s *ArticleUserSerializer) Response() users.ProfileResponse <span class="cov8" title="1">{
        response := users.ProfileSerializer{s.C, s.ArticleUserModel.UserModel}
        return response.Response()
}</span>

type ArticleSerializer struct {
        C *gin.Context
        ArticleModel
}

type ArticleResponse struct {
        ID             uint                  `json:"-"`
        Title          string                `json:"title"`
        Slug           string                `json:"slug"`
        Description    string                `json:"description"`
        Body           string                `json:"body"`
        CreatedAt      string                `json:"createdAt"`
        UpdatedAt      string                `json:"updatedAt"`
        Author         users.ProfileResponse `json:"author"`
        Tags           []string              `json:"tagList"`
        Favorite       bool                  `json:"favorited"`
        FavoritesCount uint                  `json:"favoritesCount"`
}

type ArticlesSerializer struct {
        C        *gin.Context
        Articles []ArticleModel
}

func (s *ArticleSerializer) Response() ArticleResponse <span class="cov8" title="1">{
        myUserModel := s.C.MustGet("my_user_model").(users.UserModel)
        authorSerializer := ArticleUserSerializer{s.C, s.Author}
        response := ArticleResponse{
                ID:          s.ID,
                Slug:        slug.Make(s.Title),
                Title:       s.Title,
                Description: s.Description,
                Body:        s.Body,
                CreatedAt:   s.CreatedAt.UTC().Format("2006-01-02T15:04:05.999Z"),
                //UpdatedAt:      s.UpdatedAt.UTC().Format(time.RFC3339Nano),
                UpdatedAt:      s.UpdatedAt.UTC().Format("2006-01-02T15:04:05.999Z"),
                Author:         authorSerializer.Response(),
                Favorite:       s.isFavoriteBy(GetArticleUserModel(myUserModel)),
                FavoritesCount: s.favoritesCount(),
        }
        response.Tags = make([]string, 0)
        for _, tag := range s.Tags </span><span class="cov0" title="0">{
                serializer := TagSerializer{s.C, tag}
                response.Tags = append(response.Tags, serializer.Response())
        }</span>
        <span class="cov8" title="1">return response</span>
}

func (s *ArticlesSerializer) Response() []ArticleResponse <span class="cov8" title="1">{
        response := []ArticleResponse{}
        for _, article := range s.Articles </span><span class="cov8" title="1">{
                serializer := ArticleSerializer{s.C, article}
                response = append(response, serializer.Response())
        }</span>
        <span class="cov8" title="1">return response</span>
}

type CommentSerializer struct {
        C *gin.Context
        CommentModel
}

type CommentsSerializer struct {
        C        *gin.Context
        Comments []CommentModel
}

type CommentResponse struct {
        ID        uint                  `json:"id"`
        Body      string                `json:"body"`
        CreatedAt string                `json:"createdAt"`
        UpdatedAt string                `json:"updatedAt"`
        Author    users.ProfileResponse `json:"author"`
}

func (s *CommentSerializer) Response() CommentResponse <span class="cov8" title="1">{
        authorSerializer := ArticleUserSerializer{s.C, s.Author}
        response := CommentResponse{
                ID:        s.ID,
                Body:      s.Body,
                CreatedAt: s.CreatedAt.UTC().Format("2006-01-02T15:04:05.999Z"),
                UpdatedAt: s.UpdatedAt.UTC().Format("2006-01-02T15:04:05.999Z"),
                Author:    authorSerializer.Response(),
        }
        return response
}</span>

func (s *CommentsSerializer) Response() []CommentResponse <span class="cov0" title="0">{
        response := []CommentResponse{}
        for _, comment := range s.Comments </span><span class="cov0" title="0">{
                serializer := CommentSerializer{s.C, comment}
                response = append(response, serializer.Response())
        }</span>
        <span class="cov0" title="0">return response</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package articles

import (
        "github.com/gosimple/slug"
        "realworld-backend/common"
        "realworld-backend/users"
        "github.com/gin-gonic/gin"
)

type ArticleModelValidator struct {
        Article struct {
                Title       string   `form:"title" json:"title" binding:"required,min=4"`
                Description string   `form:"description" json:"description" binding:"max=2048"`
                Body        string   `form:"body" json:"body" binding:"max=2048"`
                Tags        []string `form:"tagList" json:"tagList"`
        } `json:"article"`
        articleModel ArticleModel `json:"-"`
}

func NewArticleModelValidator() ArticleModelValidator <span class="cov8" title="1">{
        return ArticleModelValidator{}
}</span>

func NewArticleModelValidatorFillWith(articleModel ArticleModel) ArticleModelValidator <span class="cov0" title="0">{
        articleModelValidator := NewArticleModelValidator()
        articleModelValidator.Article.Title = articleModel.Title
        articleModelValidator.Article.Description = articleModel.Description
        articleModelValidator.Article.Body = articleModel.Body
        for _, tagModel := range articleModel.Tags </span><span class="cov0" title="0">{
                articleModelValidator.Article.Tags = append(articleModelValidator.Article.Tags, tagModel.Tag)
        }</span>
        <span class="cov0" title="0">return articleModelValidator</span>
}

func (s *ArticleModelValidator) Bind(c *gin.Context) error <span class="cov0" title="0">{
        myUserModel := c.MustGet("my_user_model").(users.UserModel)

        err := common.Bind(c, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.articleModel.Slug = slug.Make(s.Article.Title)
        s.articleModel.Title = s.Article.Title
        s.articleModel.Description = s.Article.Description
        s.articleModel.Body = s.Article.Body
        s.articleModel.Author = GetArticleUserModel(myUserModel)
        s.articleModel.setTags(s.Article.Tags)
        return nil</span>
}

type CommentModelValidator struct {
        Comment struct {
                Body string `form:"body" json:"body" binding:"max=2048"`
        } `json:"comment"`
        commentModel CommentModel `json:"-"`
}

func NewCommentModelValidator() CommentModelValidator <span class="cov8" title="1">{
        return CommentModelValidator{}
}</span>

func (s *CommentModelValidator) Bind(c *gin.Context) error <span class="cov0" title="0">{
        myUserModel := c.MustGet("my_user_model").(users.UserModel)

        err := common.Bind(c, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.commentModel.Body = s.Comment.Body
        s.commentModel.Author = GetArticleUserModel(myUserModel)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package common

import (
        "fmt"
        "github.com/jinzhu/gorm"
        _ "github.com/jinzhu/gorm/dialects/sqlite"
        "os"
)

type Database struct {
        *gorm.DB
}

var DB *gorm.DB

// Opening a database and save the reference to `Database` struct.
func Init() *gorm.DB <span class="cov8" title="1">{
        db, err := gorm.Open("sqlite3", "./../gorm.db")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("db err: (Init) ", err)
        }</span>
        <span class="cov8" title="1">db.DB().SetMaxIdleConns(10)
        //db.LogMode(true)
        DB = db
        return DB</span>
}

// This function will create a temporarily database for running testing cases
func TestDBInit() *gorm.DB <span class="cov8" title="1">{
        test_db, err := gorm.Open("sqlite3", "./../gorm_test.db")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("db err: (TestDBInit) ", err)
        }</span>
        <span class="cov8" title="1">test_db.DB().SetMaxIdleConns(3)
        test_db.LogMode(true)
        DB = test_db
        return DB</span>
}

// Delete the database after running testing cases.
func TestDBFree(test_db *gorm.DB) error <span class="cov8" title="1">{
        test_db.Close()
        err := os.Remove("./../gorm_test.db")
        return err
}</span>

// Using this function to get a connection, you can create your connection pool here.
func GetDB() *gorm.DB <span class="cov8" title="1">{
        return DB
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Common tools and helper functions
package common

import (
        "fmt"
        "math/rand"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "github.com/go-playground/validator/v10"

        "github.com/gin-gonic/gin/binding"
        "github.com/gin-gonic/gin"
)

var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

// A helper function to generate random string
func RandString(n int) string <span class="cov8" title="1">{
        b := make([]rune, n)
        for i := range b </span><span class="cov8" title="1">{
                b[i] = letters[rand.Intn(len(letters))]
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}

// Keep this two config private, it should not expose to open source
const NBSecretPassword = "A String Very Very Very Strong!!@##$!@#$"
const NBRandomPassword = "A String Very Very Very Niubilty!!@##$!@#4"

// A Util function to generate jwt_token which can be used in the request header
func GenToken(id uint) string <span class="cov8" title="1">{
        jwt_token := jwt.New(jwt.GetSigningMethod("HS256"))
        // Set some claims
        jwt_token.Claims = jwt.MapClaims{
                "id":  id,
                "exp": time.Now().Add(time.Hour * 24).Unix(),
        }
        // Sign and get the complete encoded token as a string
        token, _ := jwt_token.SignedString([]byte(NBSecretPassword))
        return token
}</span>

// My own Error type that will help return my customized Error info
//  {"database": {"hello":"no such table", error: "not_exists"}}
type CommonError struct {
        Errors map[string]interface{} `json:"errors"`
}

// To handle the error returned by c.Bind in gin framework
// https://github.com/go-playground/validator/blob/v9/_examples/translations/main.go
func NewValidatorError(err error) CommonError <span class="cov8" title="1">{
        res := CommonError{}
        res.Errors = make(map[string]interface{})
        errs := err.(validator.ValidationErrors)
        for _, v := range errs </span><span class="cov8" title="1">{
                // can translate each error one at a time.
                //fmt.Println("gg",v.NameNamespace)
                if v.Param() != "" </span><span class="cov8" title="1">{
                        res.Errors[v.Field()] = fmt.Sprintf("{%v: %v}", v.Tag(), v.Param())
                }</span> else<span class="cov8" title="1"> {
                        res.Errors[v.Field()] = fmt.Sprintf("{key: %v}", v.Tag())
                }</span>

        }
        <span class="cov8" title="1">return res</span>
}

// Warp the error info in a object
func NewError(key string, err error) CommonError <span class="cov8" title="1">{
        res := CommonError{}
        res.Errors = make(map[string]interface{})
        res.Errors[key] = err.Error()
        return res
}</span>

// Changed the c.MustBindWith() -&gt;  c.ShouldBindWith().
// I don't want to auto return 400 when error happened.
// origin function is here: https://github.com/gin-gonic/gin/blob/master/context.go
func Bind(c *gin.Context, obj interface{}) error <span class="cov8" title="1">{
        b := binding.Default(c.Request.Method, c.ContentType())
        return c.ShouldBindWith(obj, b)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
